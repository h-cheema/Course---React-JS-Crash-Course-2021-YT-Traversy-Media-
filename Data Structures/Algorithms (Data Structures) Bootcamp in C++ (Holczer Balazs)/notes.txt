Algorithms (Data Structures) Bootcamp in C++



Section 2: Algorithms - Recursion

    2. What are stack and heap memory?
    - Both are their own specific regions on RAM. Data types are stack and heap.
    - Stack: small, fast access, stores func calls and local vars, no fragmentation.
        - LIFO - last in first out.
    - Heap: large, slow access, stores objects, can become fragmented.
        - FIFO - first in first out.
    
    4. What is recursion (recursive function call)?
    - Recursion is one of the central computer science ideas.
    - We can transform recursion into iteration and back.
    - Recursion is very elegant.
    - Base cases are used to avoid infinite loops.
    - Head and tail recursion:
        - Tail: recursive call is at end of function. Similar to a for loop.
        - Head: recursive call is at the start of the function. method saves state, requiring more memory.

    
    5. Head and tail recursion implementation
    - 

    
    6. Recursion and stack memory (stack overflow)
    - 
    
    7. Factorial problem
    - 
    
    8. Fibonacci numbers problem
    - 
    
    9. Fibonacci numbers - visualizing the stack memory
    - 
    
    10. Fibonacci-numbers with tail recursion
    - 
    
    11. Towers of Hanoi introduction
    - 
    
    12. Towers of Hanoi implementation
    - 
    
    13. Towers of Hanoi - visualizing the stack
    - 
    
    14. Recursion and iteration (differences)
    - 

Section 3: Search Algorithms

    
    15. What is linear search?
    - 
    
    16. Linear search implementation
    - 
    
    17. What is binary (logarithmic) search?
    - 
    
    18. Binary search implementation
    - 

Section 4:  Algorithms - Backtracking

    
    19. What is backtracking?
    - 
    
    20. Brute-force search and backtracking
    - 
    
    21. N-queens problem introduction
    - 
    
    22. N-queens problem implementation
    - 
    
    23. N-queens problem and the stack memory
    - 
    
    24. Coloring problem introduction
    - 
    
    25. Coloring problem visualization
    - 
    
    26. Coloring problem implementation
    - 
    
    27. Knight's tour problem introduction
    - 
    
    28. Knight's tour problem implementation
    - 
    
    29. What is the problem with backtracking?
    - 

Section 5: Algorithms - Dynamicg

    
    30. What is dynamicg?
    - 
    
    31. Fibonacci numbers introduction
    - 
    
    32. Fibonacci numbers implementation
    - 
    
    33. Knapsack problem introduction
    - 
    
    34. Knapsack problem example
    - 
    
    35. Knapsack problem implementation
    - 

Section 6: Data Structures and Abstract Data Types Overview

    
    36. Why to use data structures
    - 
    
    37. Data structures and abstract data types
    - 

Section 7: Data Structures - Arrays

    
    38. What are array data structures?
    - 
    
    39. Arrays introduction - operations
    - 
    
    40. Arrays in C++
    - 

Section 8: Data Structures - Linked Lists

    
    41. What are linked lists?
    - 
    
    42. Linked list theory - operations
    - 
    
    43. Linked list implementation
    - 
    
    44. Comparing linked lists and arrays
    - 
    
    45. Practical (real-world) applications of linked lists
    - 

Section 9: Data Structures - Stacks

    
    46. What are stacks?
    - 
    
    47. Stacks in memory management (stacks and heaps)
    - 
    
    48. Stack memory visualization
    - 
    
    49. Stacks implementation with arrays
    - 
    
    50. Stack implementation with linked lists
    - 
    
    51. Practical (real-world) applications of stacks
    - 

Section 10: Data Structures - Queues

    
    52. What are queues?
    - 
    
    53. Queue implementation with linked list
    - 

Section 11:  Data Structures - Trees|1hr

    
    54. Binary search trees theory - basics
    - 
    
    55. Binary search trees theory - search, insert
    - 
    
    56. Binary search trees theory - delete
    - 
    
    57. Binary search trees theory - in-order traversal
    - 
    
    58. Binary search trees theory - running times
    - 
    
    59. Binary search tree implementation I
    - 
    
    60. Stack memory visualization - finding max ) items
    - 
    
    61. Stack memory visualization - tree traversal
    - 
    
    62. Binary search tree implementation II
    - 
    
    63. Binary search tree implementation III
    - 
    
    64. Practical (real-world) applications of trees
    - 

Section 12: Priority Queues (Heaps)

    
    65. What are priority queues?
    - 
    
    66. Heap introduction - basics
    - 
    
    67. Heap introduction - array representation
    - 
    
    68. Heap introduction - remove operation
    - 
    
    69. Using heap data structure to sort (heapsort)
    - 
    
    70. Heap introduction - running times
    - 
    
    71. Binomial and Fibonacci heaps
    - 
    
    72. Heaps implementation I
    - 
    
    73. Heaps implementation II
    - 

Section 13: B-Trees

    
    74. What is external memory?
    - 
    
    75. Disk access times
    - 
    
    76. What are B-trees?
    - 
    
    77. B-tree introduction - insertion
    - 
    
    78. B-tree introduction - deletion
    - 
    
    79. B-tree variants and file systems
    - 

Section 14: Associative Arrays (HashTables)

    
    80. What are associative arrays?
    - 
    
    81. Hashtables introduction - basics
    - 
    
    82. Hashtables introduction - collisions
    - 
    
    83. Hashtables introduction - load factor & dynamic resizing
    - 
    
    84. Chaining method
    - 
    
    85. Chaining method implementation
    - 
    
    86. Practical (real-world) applications of hashing
    - 

Section 15: Graph Algorithms - Overview

    
    87. Graph theory overview
    - 
    
    88. Adjacency matrix and adjacency list
    - 
    
    89. Applications of graphs
    - 

Section 16: Graph Algorithms - Breadth-First Search (BFS)

    
    90. Breadth-first search introduction
    - 
    
    91. Breadth-first search implementation
    - 
    
    92. WebCrawler (core of search engines)
    - 

Section 17: Graph Algorithms - Depth-First Search (DFS)

    
    93. Depth-first search introduction
    - 
    
    94. Depth-first search implementation
    - 
    
    95. Depth-first search and stack memory visualisation
    - 
    
    96. Memory management: BFS vs DFS
    - 

Section 18: Graph Algorithms - Dijkstra's Shortest Path Algorithm

    
    97. What is the shortest path problem?
    - 
    
    98. Dijkstra algorithm visualization
    - 
    
    99. Dijkstra algorithm implementation I
    - 
    
    100. Dijkstra algorithm implementation II
    - 
    
    101. Shortest path algorithms applications
    - 
    
    102. What is the critical path method (CPM)?
    - 

Section 19: Graph Algorithms - Bellman-Ford Algorithm

    
    103. What is the Bellman-Ford algorithm?
    - 
    
    104. Bellman-Ford algorithm visualisation
    - 
    
    105. Bellman-Ford algorithm implementation I
    - 
    
    106. Bellman-Ford algorithm implementation II
    - 
    
    107. Greedy algorithm or dynamicg approach?
    - 

Section 20:  Substring Search Algorithms|1hr

    
    108. Brute-force search introduction
    - 
    
    109. Brute-force search implementation
    - 
    
    110. Rabin-Karp algorithm introduction
    - 
    
    111. Knuth-Morris-Pratt algorithm introduction
    - 
    
    112. Constructing the partial match table
    - 
    
    113. Knuth-Morris-Pratt algorithm implementation
    - 
    
    114. Z algorithm introduction
    - 
    
    115. Z algorithm illustration
    - 
    
    116. Z algorithm implementation
    - 
    
    117. Substring search algorithms comparison
    - 
    
    118. Applications of substring search
    - 

Section 21:  Sorting Algorithms|3hr

    
    119. Sorting introduction
    - 
    
    120. What is stability in sorting?
    - 
    
    121. Adaptive sorting algorithms
    - 
    
    122. Bogo sort introduction
    - 
    
    123. Bogo sort implementation
    - 
    
    124. Bubble sort introduction
    - 
    
    125. Bubble sort implementation
    - 
    
    126. Selection sort introduction
    - 
    
    127. Selection sort implementation
    - 
    
    128. Insertion sort introduction
    - 
    
    129. Insertion sort implementation
    - 
    
    130. Shell sort introduction
    - 
    
    131. Shell sort implementation
    - 
    
    132. Quicksort introduction
    - 
    
    133. Quicksort introduction - example
    - 
    
    134. Quicksort implementation
    - 
    
    135. Hoare's partitioning and Lomuto's partitioning
    - 
    
    136. What is the worst-case scenario for quicksort?
    - 
    
    137. Merge sort introduction
    - 
    
    138. Merge sort implementation
    - 
    
    139. Merge sort and stack memory visualization
    - 
    
    140. Hybrid algorithms introduction
    - 
    
    141. Non-comparison based algorithms
    - 
    
    142. Counting sort introduction
    - 
    
    143. Counting sort implementation
    - 
    
    144. Radix sort introduction
    - 
    
    145. Radix sort implementation
    - 

Section 22: DOWNLOADS (Course Materials)

    
    146. Course materials
    - 
    
    147. Sorting algorithms source code
    - 

Section 23: Algorhyme FREE Algorithms Visualizer App

    
    148. Algorithms Visualization App
    - 
    
    149. Algorhyme - Algorithms and Data Structures - 