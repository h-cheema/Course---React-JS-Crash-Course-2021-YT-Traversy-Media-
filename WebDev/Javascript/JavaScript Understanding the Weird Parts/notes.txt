JavaScript: Understanding the Weird Parts
git commit -am "JavaScript UTWP - Finished lecture /85"



Section 1: Getting Started - 15min

    1. Introduction and The Goal of This Course
    - js is nothing like other similar looking languages, such as java or c++
        - js is a different paradigm than those languages.
    - js is deceptively powerful and beautiful.
    - Philosophy: Don't immitate. Understand.
        - Don't immitate js code.
        - Immitation -> When you have to debug or make code from scratch, you will have major problems.
    
    5. Understanding, Frameworks, and The Weird Parts
    - When you learn js through JQuery and Node, you don't get a deep understanding of js.
    - You should build a very strong core js skillset first.
    - Understanding weird parts = Understanding the hows and whys.


Section 2: Execution Contexts and Lexical Environments - 1hr 34min

    6. Conceptual Aside: Syntax Parsers, Execution Contexts, and Lexical Environments
    - Syntax parser
        -Translates syntax to computer instructions.
        - Parser can do extra stuff to translation.
    - Lexical Environment 
        - Where it's written and what surrounds it.
        - Where the code physically sits in memory.
    - Execution Context
        - Wrapper helps manage the running code.
        - Can do beyond what your code does.
    
    7. Conceptual Aside: Name/Value Pairs and Objects
    - Name can be defined many times but can only have one value. (Exe context)
    - Object: Collection of name value pairs.
        - value of a name could be another object. This can nest downwards.
    
    9. The Global Environment and The Global Object
    - js engine creates a "global object" and "this" when you run code.
    - Global: means not inside a function.
    - js wraps your code in the execution context

    11. Conceptual Aside: Javascript and 'undefined'
    - === is safer than ==
    - Uncaught ReferenceError = Thing is not in memory at all.
    - Undefined = a special value initially set by JS. Undefined != null.
        - var a; 
            - Always better to let js handle it like this.
            - This way you know if something is unintentionally undefined.
        - var a - undefined;
            - Manual way to set undefined. Hard to know if you or js set it.
            - Harder to know if you made something undefined.

    13. Conceptual Aside: Single Threaded, Synchronous Execution
    - Single threaded: One command is executed at a time.
    - Synchronous execution: One at a time, and in order.

    15. Functions, Context, and Variable Environments
    - A scope is an execution context.

    17. Scope, ES6, and let
    - let
        - Can be used instead of var.
        - Uses block scoping.

    18. What About Asynchronous Callbacks?
    - Whats happens inside the JS engine is specifically synchronous.
    - What happens outside the engine can be asynchronous.


Section 3: Types and Operators - 1hr 18min

    19. Conceptual Aside: Types and Javascript
    - JS is dynamically typed.

    20. Primitive Types
    - Primitives represent a single value, not an object.
    - object = collection of key value pairs.
    - Undefined = lack of existence and code did not set a value (programmer should not assign this).
    - null = variable is equal to nothing (set by programmer).
    - number = float
    - string = sequence of characters. In js a string is a prim type.
    - symbol = value is kept private for internal use.

    21. Conceptual Aside: Operators
    - 3 + 4 = infix notation.
    - + 3 4 = prefix notation.
    - 3 4 + = profix notation.
    - console.log(+(3,4)) = valid js.

    22. Operator Precedence and Associativity
    - Means which operator gets called first
    - Associativity = left to right or right to left
    - a = b is a function that returns a value (value to the right)

    23. Operator Precedence and Associativity Table
    - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence

    24. Conceptual Aside: Coercion
    - Means converting a value from one type to another type.
    - Coercion happens behind the scenes, like 1 + '2' will become '12'.

    25. Comparison Operators
    - Number(x) = check what x coerces to.
    - Coercion can cause unexpected results that cause very tricky bugs.
    - Number(undefined) = NaN.
    - Number(null) = 0.
    - === will help prevent unexpectedly coerced comparison. 
        - false == 0 = true
        - false === 0 = false
    - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness

    27. Existence and Booleans
    - 

    28. Default Values
    - 

    29. Framework Aside: Default Values
    - 


Section 4: Objects and Functions - 4hr 28min
Section 5: Object-Oriented Javascript and Prototypal Inheritance - 40min
Section 6: Building Objects - 1hr 7min
Section 7: Odds and Ends - 19min
Section 8: Examining Famous Frameworks and Libraries - 52min
Section 9: Let's Build a Framework / Library! - 49min
Section 10: BONUS Lectures - 5min
Section 11: BONUS: Getting Ready for ECMAScript 6 - 1min
Section 12: Conclusion - 1min